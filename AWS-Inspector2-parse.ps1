
#Import the Inspector2 powershell module to be able to create the following object. Needed for -FilterCriteria_Severity that only understand Amazon.Inspector2.Model.StringFilter object type.
Import-Module AWS.Tools.Inspector2

#Set the default location to script location
Set-Location -Path $PSScriptRoot

#Create an Amazon.Inspector2.StringComparison object needed for Amazon.Inspector2.Model.StringFilter object.
$titi = [Amazon.Inspector2.StringComparison]::new("EQUALS")

#Create mutliple Amazon.Inspector2.Model.StringFilter objects for each criticity recognised by the filter.
[Amazon.Inspector2.Model.StringFilter]$toto = @{
    Comparison = $titi
    value = "CRITICAL"
}
[Amazon.Inspector2.Model.StringFilter]$yoyo = @{
    Comparison = $titi
    value = "HIGH"
}
# [Amazon.Inspector2.Model.StringFilter]$coco = @{
#     Comparison = $titi
#     value = "MEDIUM"
# }
# [Amazon.Inspector2.Model.StringFilter]$bobo = @{
#     Comparison = $titi
#     value = "LOW"
# }
# [Amazon.Inspector2.Model.StringFilter]$zozo = @{
#     Comparison = $titi
#     value = "UNTRIAGED"
# }
# [Amazon.Inspector2.Model.StringFilter]$dodo = @{
#     Comparison = $titi
#     value = "INFORMATIONAL"
# }

#Combine as much Severity object as desired.
$Filter = $toto, $yoyo
#S3 Bucket name where the JSON generated by Inspector will be stored
$S3Bucketname = 
#KMS Key ARN. KMS Key will encrypt the JSON file
$KMSKeyARN = 

# #Create a findings report in JSON from AWS CLI Inspector
$json_file = New-INS2FindingsReport -ReportFormat JSON -S3Destination_BucketName $S3Bucketname -S3Destination_KmsKeyArn $KMSKeyARN -FilterCriteria_Severity $Filter
#Exception management. Check if the json variable is not empty. Means the previous command was successful.
if ($NULL -eq $json_file){
    Write-Host "New-INS2FindingsReport didn't work."
    Exit
}

#Check if file exists in the bucket S3 before downloading it. Adjust the waiting time as you wish.
while (-not (Get-S3Object -BucketName "S3 BUCKET NAME where the" -KeyPrefix $json_file )) {
    start-sleep -Seconds 60
} 
# #Download the JSON file from the S3 bucket.
Copy-S3Object -BucketName "axawsfr1m-s3-inspector-971842448392" -Key "$json_file.json" -LocalFile "inspector.json"

#Read the JSON file. Deleting some problematic characters
$json = Get-Content -Path "inspector.json" | ForEach-Object{$_ -replace '{"findings":'} | ForEach-Object{$_ -replace ';','.'} | ForEach-Object{$_ -replace '\\n', ' '} | ForEach-Object{$_ -replace '\\"', '*'} | ForEach-Object{$_ -replace '\\'}
$json[-1] = $json[-1] -replace '.$'
$json = $json | ConvertFrom-Json

# Regrouping object by resource type since some index are different.
$objects = foreach ($data in $json) {
    if ("AWS_EC2_INSTANCE" -eq $data.resources.type) {
        [PSCustomObject]@{    
            AccountID                                 = $data.awsAccountID
            Platform                                  = $data.resources.details.awsEc2Instance.platform
            Owner                                     = $data.resources.tags.owner
            Title                                     = $data.title
            Severity                                  = $data.severity
            Description                               = $data.description
            ExploitAvailable                          = $data.exploitAvailable
            FixAvailable                              = $data.fixAvailable
            References                                = $data.packageVulnerabilityDetails.referenceUrls -join ","
            SourceUrl                                 = $data.packageVulnerabilityDetails.sourceUrl
            Remediation                               = $data.packageVulnerabilityDetails.vulnerablePackages.remediation -join ","
            Instance_ID                               = $data.resources.id
            ImageId                                   = $data.resources.details.awsEc2Instance.imageId
            Type                                      = $data.resources.type
            # you can Add Some Tags to organise the CSV with more meaningful information for your Infra.
            # Example
            # Name                                      = $data.resources.tags.Name
            # Environment                               = $data.resources.tags.environment
            # Application_name                          = $data.resources.tags.application_name
            # Application_group                         = $data.resources.tags.application_group
        }
    }
    elseif ("AWS_ECR_CONTAINER_IMAGE" -eq $data.resources.type) {
        [PSCustomObject]@{
            AccountID                                 = $data.awsAccountId
            repositoryName                            = $data.resources.details.awsEcrContainerImage.repositoryName
            ImageTags                                 = $data.resources.details.awsEcrContainerImage.imageTags
            Platform                                  = $data.resources.details.awsEcrContainerImage.platform
            Title                                     = $data.title
            Severity                                  = $data.severity
            Description                               = $data.description
            ExploitAvailable                          = $data.exploitAvailable
            FixAvailable                              = $data.fixAvailable
            References                                = $data.packageVulnerabilityDetails.referenceUrls -join ","
            SourceUrl                                 = $data.packageVulnerabilityDetails.sourceUrl
            Remediation                               = $data.packageVulnerabilityDetails.vulnerablePackages.remediation -join ","
            Type                                      = $data.resources.type
        }

    }
    elseif ("AWS_LAMBDA_FUNCTION" -eq $data.resources.type) {
        [PSCustomObject]@{
            AccountID                                 = $data.awsAccountId
            functionName                              = $data.resources.details.awsLambdaFunction.functionName
            runtime                                   = $data.resources.details.awsLambdaFunction.runtime
            Title                                     = $data.title
            Severity                                  = $data.severity
            Description                               = $data.description
            ExploitAvailable                          = $data.exploitAvailable
            FixAvailable                              = $data.fixAvailable
            References                                = $data.packageVulnerabilityDetails.referenceUrls -join ","
            SourceUrl                                 = $data.packageVulnerabilityDetails.sourceUrl
            Remediation                               = $data.packageVulnerabilityDetails.vulnerablePackages.remediation -join ","
            Type                                      = $data.resources.type
        }
    }
}
# Export the modified object to a CSV file by Resource Type.
$objects | where-object Type -eq "AWS_EC2_INSTANCE" | Select-Object -Property * | Export-Csv -Path "$((Get-Date).ToString("yyyyMMdd_HHmmss"))_EC2.csv" -Delimiter "|" -NoTypeInformation

$objects | where-object Type -eq "AWS_ECR_CONTAINER_IMAGE" | Select-Object -Property * | Export-Csv -Path "$((Get-Date).ToString("yyyyMMdd_HHmmss"))_ECR.csv" -Delimiter "|" -NoTypeInformation

$objects | where-object Type -eq "AWS_LAMBDA_FUNCTION" | Select-Object -Property * | Export-Csv -Path "$((Get-Date).ToString("yyyyMMdd_HHmmss"))_Lambda.csv" -Delimiter "|" -NoTypeInformation
